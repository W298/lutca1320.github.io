---
title: 도로 제작 - Snapping 시스템
author: RUKA SPROUT
date: 2020-07-23 18:54:00 +0900
categories:
tags:
---

![background](./back.png)

도로를 그릴 때 그리드에 맞춰 Snapping 이 된다면 훨씬 깔끔한 도로를 만들 수 있을 것이다.

Build 모드에서 Spline 의 첫 시작점을 지정할 때, Append 모드에서 Append 를 진행할 때마다 호출되는 함수가 필요하다.

## 1. SnapGrid 함수

Snapping 에는 여러가지 방법이 있지만, 먼저 Mathf.Round 를 이용해 함수를 제작하였다.

```csharp
float SnapGrid(float value, int snapsize)
    {
        if (value < 0)
        {
            return Mathf.Round(Mathf.Abs(value / snapsize)) * snapsize * -1;
        }
        else
        {
            return Mathf.Round(value / snapsize) * snapsize;
        }
    }
```

value 값을 snapsize 만큼의 그리드로 반올림한다. 음수인 경우는 절대값을 반올림한 뒤 -1을 곱해 따로 리턴 값을 준비해 주었다.

만약 value = 12, snapsize = 10 이면 10 으로 내림되고, value = 18 이면 20 으로 올림된다.

이 함수를 사용하다 보니 문제가 하나 있었다. 대각선 방향으로 한번에 움직이지 못한다는 것이다. 위 함수를 이용하면 x 값 따로 z 값 따로 리턴을 받기 때문에 x = z = snapsize / 2 일때를 제외하고 대각선으로 한번에 이동할 수 없다.
그리드를 따라 이동할 때마다 도로가 Append 되기 때문에 대각선 방향으로 한번에 이동하지 않는다면 대각선 방향의 도로는 그릴 수 없다.



## 2. SnapToGridPoint 함수

이 문제를 해결하기 위해 새로운 함수가 필요해 보였다. 이번에는 주변에 Area 를 지정해 각 Area 에 들어가면 지정된 위치로 이동하는 방법을 사용하였다. 이 방법을 사용하면 대각선으로 이동하는 Area 를 지정해 놓고, 그 Area 에 들어오면 대각선으로 이동하게 할 수 있다.

```csharp
Vector3 SnapToGridPoint(Vector3 pos, int _snapsize)
    {
        float snapsize = (float)_snapsize;

        if (!isVectorInXZArea(pos, -snapsize + last_pos.x, snapsize + last_pos.x, 
            -snapsize + last_pos.z, snapsize + +last_pos.z))
        {
            UnityEngine.Debug.LogWarning("Out of range!");
        }
        else
        {
            if (isVectorInXZArea(pos, snapsize / 2 + last_pos.x, snapsize + last_pos.x,
            last_pos.z - snapsize / 4, last_pos.z + snapsize / 4))
            {
                last_pos = last_pos + new Vector3(snapsize, 0, 0);
                return last_pos;
            }
            else if (isVectorInXZArea(pos, last_pos.x - snapsize, last_pos.x - snapsize / 2,
                last_pos.z - snapsize / 4, last_pos.z + snapsize / 4))
            {
                last_pos = last_pos - new Vector3(snapsize, 0, 0);
                return last_pos;
            }
            else if (isVectorInXZArea(pos, last_pos.x - snapsize / 4, last_pos.x + snapsize / 4,
                last_pos.z + snapsize / 2, last_pos.z + snapsize))
            {
                last_pos = last_pos + new Vector3(0, 0, snapsize);
                return last_pos;
            }
            else if (isVectorInXZArea(pos, last_pos.x - snapsize / 4, last_pos.x + snapsize / 4,
                last_pos.z - snapsize, last_pos.z - snapsize / 2))
            {
                last_pos = last_pos - new Vector3(0, 0, snapsize);
                return last_pos;
            }
            else if (isVectorInXZArea(pos, last_pos.x + snapsize / 2, last_pos.x + snapsize,
                last_pos.z + snapsize / 2, last_pos.z + snapsize))
            {
                last_pos = last_pos + new Vector3(snapsize, 0, snapsize);
                return last_pos;
            }
            else if (isVectorInXZArea(pos, last_pos.x - snapsize, last_pos.x - snapsize / 2,
                last_pos.z + snapsize / 2, last_pos.z + snapsize))
            {
                last_pos = last_pos + new Vector3(-snapsize, 0, snapsize);
                return last_pos;
            }
            else if (isVectorInXZArea(pos, last_pos.x + snapsize / 2, last_pos.x + snapsize,
                last_pos.z - snapsize, last_pos.z - snapsize / 2))
            {
                last_pos = last_pos + new Vector3(snapsize, 0, -snapsize);
                return last_pos;
            }
            else if (isVectorInXZArea(pos, last_pos.x - snapsize, last_pos.x - snapsize / 2,
                last_pos.z - snapsize, last_pos.z - snapsize / 2))
            {
                last_pos = last_pos - new Vector3(snapsize, 0, snapsize);
                return last_pos;
            }
        }

        return last_pos;
    }
```

다소 복잡해 보이지만, pos 값이 어느 Area 에 위치하는지를 체크하고 지정된 값 만큼 이동시킨 뒤 리턴하는 코드이다.
last_pos 이라는 전역 변수가 있는데, 이는 그리드에 Snapping 된 전 pos 값으로 중심값으로 이용한다.

이 함수의 치명적인 문제점이 있는데, pos 이 지정한 snapsize x snapsize Area 를 벗어나면 Snapping 이 불가능하다는 것이다.

그렇기 때문에 모든 입력에 대해서 Snapping 이 필요한 Build 모드에서는 SnapGrid 함수를, 한 칸씩만 체크하면 되는 Append 모드에서는 SnapToGridPoint 함수를 이용하여 문제를 보완하였다. 어차피 Build 모드에서는 대각선으로 그릴 일이 없기 때문이다.